# 第七章：理解处理器

虽然第2章和第3章的全部理论，已经可以让我们去编写正确的并发代码，但是更进一步，大概了解一下在处理器层面，一切都是怎么运行的，这对我们也会非常有帮助。在这一章节，我们将会探索原子操作最终编译后的机器码是什么样、不同架构的处理器之间的差异、为什么会有一个弱版本的 `compare_exchange`存在 、在最底层的每个独立指令中内存顺序是什么， <u>以及如果通过缓存将这一切联系起来</u>[需校对]。

这一章的目标不是为了理解每种处理器架构的相关细节，如果这样的话，就需要我们去查阅大量大量的书籍，其中有些内容或许还没被著成书，或者根本没被公开。本章节的目标是让大家对于原子操作在处理器层面是如何工作的这一点，有一个大概的认知，并且在实现或者优化单个的原子化代码的时候，可以做出更多有依据的决策。当然，<u>也是简单地满足一下我们后面场景会是什么的好奇心[需校对]</u> ——  从抽象的理论中休息一下吧。

为了尽可能的具体化，我们只关注两种特定的处理器架构：

X86-64:

Intel 和 AMD 实现的64位x86架构处理器主要用于笔记本、台式机、服务器和一些游戏机主机。最初的x86架构的16位版本和之后非常流行的32位版本是 Intel 开发的，而64位的版本，也就是我们今天称作x86-64版本，最初是AMD开发的一种扩展版本，因此也常叫作 AMD64。Intel也开发了自己的64位架构：IA-64，<u>但是最终认定x86-64架构是较流行的AMD的x86扩展版本（包含命名的 IA-32e, EM64T，和之后的Intel 64）[需校对]</u>。

ARM64：

ARM架构的64位版本用于几乎所有的现代移动设备、高性能的嵌入式系统、最近生产的笔记本电脑和台式机中。同时也以 AArch64 被众人所知，并被引入到了 ARMv8，成为其一部分。ARM的早期版本(32位)，以各种方式，广泛地使用在各种应用中。在可以想到的许多嵌入式系统中，从汽车到电子 COVID 检测器，流行的微控制器都是基于ARMv6 和 ARMv7。

这两种架构在许多方面都是不同的。最重要的是，他们以不同的方式去实现原子化。理解这两种架构中原子化如何工作的，将会给我们一些更加共性的理解，并且这些也可以适用于许多其他的处理器架构。

## 处理器指令

我们可以近距离观察编译器输出的处理器可执行指令，以此对于在处理器层面对所有事情的运转有一个大致的了解。


### 汇编语言简介

当编译任何以编译语言（比如 rust 或者 C）编写的软件的时候，你的代码将会翻译成可以被处理器执行的机器指令，最终处理器将会以此执行你的程序。这些指令，针对你代码所编译的架构来说，是高度明确的。

这些机器指令也被称作机器码，是以二进制格式编码的，并且对人类来说，可读性相当的差。对于这些指令，汇编语言是人类可阅读的代表。每一个指令用一行文本表示，通常以一个单词或者缩写表示指令，后面再跟上它的参数或者操作数。`assembler` 将一段汇编文本转换成二进制表示， `disassembler` 则相反。

像 Rust 语言，编译之后，源代码的大部分结构将会丢失。依据组织结构的层级，函数与函数之前的调用或许仍然能被识别出来。但是，像结构体或者枚举这些类型会被转变为字节和地址，循环和条件处理会被转变为基本跳转或者分支指令的扁平结构。

这里有一个示例，展示汇编长什么模样的一小段代码片段，用于某个虚拟的架构里面的：

```
ldr x, 1234 // 从内存地址的1234中取值，赋给 x  
li y, 0     // 将 y 设置为 0
inc x       // 增加 x
add y, x    // 将 x 加 y 
mul x, 3    // 将 x 乘以 3
cmp y, 10   // y 与 10 进行比较
jne -5      // 如果不等于的话，指令跳转，回退5个指令
str 1234, x // 将 x 存储到内存地址1234处
```

在这个示例中， x 和 y 被称为 `register`。 `register` 是处理器的一部分，不属于主内存，通常保存单个数值或者内存地址。在64位的架构中，他们一般是64位的大小。 在不同的架构中，`register`的个数可能是不一样的，但通常个数也是非常有限的。`register` 基本用于计算过程中的临时存储，是将数据写回内存前存放中间结果的地方。

特定内存位置的常量，例如上面示例中的 -5和1234，经常是以人类更容易阅读的标签来代替。在将汇编转换成机器码的时候，`assembler` 会自动将他们替换为实际的地址。

使用标签的话，上面的示例可能是这样的：

```
         ldr x, SOME_VAR
         li y, 0
my_loop: inc x
         add y, x
         mul x, 3
         cmp y, 10
         jne my_loop
         str SOME_VAR, x
```

由于标签名只是汇编的一部分，并不是二进制机器码的，所以`disassembler`不知道原始的标签名是什么，将机器码转换到汇编的时候，极大可能地只是生成一个无意义的标签名，比如 `label1` 和 `var2`。

所有不同架构下的全部汇编学习课程，并不在本书的范围内，也不是阅读本章的必备条件。常规的理解已经足够去弄懂这些示例代码了，我们只阅读汇编，不去写它。每个示例中相关的指令已经解释的足够详细，对于先前没有汇编经验的人来说，也可以跟得上。



### 概述

为了去看 Rust 编译器产生的特定机器码，我们有几个操作选项。我们可以像平常一样编译我们的代码，然后使用 `disassembler`（比如 objdump），将生成的二进制文件转成汇编。



### 加载和存储操作

### 读、修改、写操作

#### x86 锁前缀

#### x86 比较和交换指令

## 缓存

### 缓存一致性

#### 写入协议

#### MESI 协议

### 对性能的影响

## 重排

## 内存排序

### x86-64：强排序

### ARM64：弱排序

### 一个实验

### 内存屏障

## 总结

<p style="text-align: center; padding-block-start: 5rem;">
  <a href="./8_Operating_System_Primitives.html">下一篇，第八章：操作系统原语</a>
</p>
