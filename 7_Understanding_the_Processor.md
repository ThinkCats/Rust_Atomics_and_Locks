# 第七章：理解处理器

虽然第2章和第3章的全部理论，已经可以让我们去编写正确的并发代码，但是更进一步，大概了解一下在处理器层面，一切都是怎么运行的，这对我们也会非常有帮助。在这一章节，我们将会探索原子操作最终编译后的机器码是什么样、不同架构的处理器之间的差异、为什么会有一个弱版本的 `compare_exchange`存在 、在最底层的每个独立指令中内存顺序是什么， <u>以及如果通过缓存将这一切联系起来</u>[需校对]。

这一章的目标不是为了理解每种处理器架构的相关细节，如果这样的话，就需要我们去查阅大量大量的书籍，其中有些内容或许还没被著成书，或者根本没被公开。本章节的目标是让大家对于原子操作在处理器层面是如何工作的这一点，有一个大概的认知，并且在实现或者优化单个的原子化代码的时候，可以做出更多有依据的决策。当然，<u>也是简单地满足一下我们后面场景会是什么的好奇心[需校对]</u> ——  从抽象的理论中休息一下吧。

为了尽可能的具体化，我们只关注两种特定的处理器架构：

X86-64:

Intel 和 AMD 实现的64位x86架构处理器主要用于笔记本、台式机、服务器和一些游戏机主机。最初的x86架构的16位版本和之后非常流行的32位版本是 Intel 开发的，而64位的版本，也就是我们今天称作x86-64版本，最初是AMD开发的一种扩展版本，因此也常叫作 AMD64。Intel也开发了自己的64位架构：IA-64，<u>但是最终认定x86-64架构是较流行的AMD的x86扩展版本（包含命名的 IA-32e, EM64T，和之后的Intel 64）[需校对]</u>。

ARM64：

ARM架构的64位版本用于几乎所有的现代移动设备、高性能的嵌入式系统、最近生产的笔记本电脑和台式机中。同时也以AArch64被众人所知，并被引入到了ARMv8，成为其一部分。ARM的早期版本(32位)，以各种方式，广泛地使用在各种应用中。在可以想到的许多嵌入式系统中，从汽车到电子COVID检测器，流行的微控制器都是基于ARMv6 和 ARMv7。

这两种架构在许多方面都是不同的。最重要的是，他们以不同的方式去实现原子化。理解这两种架构中原子化如何工作的，将会给我们一些更加共性的理解，并且这些也可以适用于许多其他的处理器架构。

## 处理器指令

### 加载和存储操作

### 读、修改、写操作

#### x86 锁前缀

#### x86 比较和交换指令

## 缓存

### 缓存一致性

#### 写入协议

#### MESI 协议

### 对性能的影响

## 重排

## 内存排序

### x86-64：强排序

### ARM64：弱排序

### 一个实验

### 内存屏障

## 总结

<p style="text-align: center; padding-block-start: 5rem;">
  <a href="./8_Operating_System_Primitives.html">下一篇，第八章：操作系统原语</a>
</p>
